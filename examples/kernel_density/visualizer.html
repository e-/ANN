<!DOCTYPE html>
<body>
  <h1>KNN Density Estimation</h1>
  <svg width="900" height="900"></svg>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-contour.v1.min.js"></script>

  <script>
function translate(x, y) { return 'translate(' + x + ',' + y + ')'; }

d3.json('result.json', (data) => {
  data.points.forEach(d => {
    d[0] = +d[0] // x
    d[1] = +d[1] // y
  })

  data.samples.forEach(d => {
    d[0][0] = +d[0][0] // x
    d[0][1] = +d[0][1] // y
    d[1] = +d[1] // density
  })

  let width = 720, height = 720;
  let svg = d3.select('svg').append('g').attr('transform', translate(90, 90))
  let bg = svg.append('g')
  let fg = svg.append('g')
  let dict = {}

  let x = d3.scaleLinear().domain(d3.extent(data.samples, d => d[0][0])).range([0, width])
  let y = d3.scaleLinear().domain(d3.extent(data.samples, d => d[0][1])).range([0, height])

  fg
    .selectAll('circle')
    .data(data.points)
    .enter()
    .append('circle')
      .attr('r', 3)
      .attr('fill', 'white')
      .attr('stroke', 'black')
      .attr('stroke-width', '2px')
      .attr('cx', d => x(d[0]))
      .attr('cy', d => y(d[1]))
  
  let bins = +data.bins;
  let color = d3.scaleSequential(d3.interpolateCool)
    .domain([0, d3.max(data.samples, d => d[1])])
  let densityMax = d3.max(data.samples, x => x[1])

  // 
  bg.selectAll('path')
    .data(d3.contours()
      .size([bins + 1, bins + 1])
      .thresholds(d3.range(0, densityMax, densityMax / 5))
      (data.samples.map(d => d[1]))
    )
    .enter()
      .append('path')
      .attr('d', d3.geoPath(d3.geoTransform({
        point: function(x, y) {
          let s = width / bins;
          this.stream.point(y * s - s * 0.5, x * s - s * 0.5)
        }
      }))) 
      .attr('fill', d => color(d.value))
})

  </script>
</body>
